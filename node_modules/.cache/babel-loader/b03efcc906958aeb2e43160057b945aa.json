{"ast":null,"code":"var _jsxFileName = \"/home/alvaradof/cursoSolidity/solidity-liquidity-staking-front/src/context/DropFactory/index.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { createContext, useEffect, useState } from \"react\";\nimport DropFactoryContract from \"../../Contracts/NftDrop.json\";\nimport StakingRewardsFactoryContract from \"../../Contracts/StakingRewards.json\";\nimport { ethers } from \"ethers\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst StakingRewardsFactoryContext = /*#__PURE__*/createContext();\nexport function StakingRewardsFactoryProvider(_ref) {\n  _s();\n\n  let {\n    children\n  } = _ref;\n  const address = DropFactoryContract.address;\n  const address_2 = StakingRewardsFactoryContract.address;\n  const abi = DropFactoryContract.abi;\n  const abi_2 = StakingRewardsFactoryContract.abi;\n  alert(abi_2);\n  const [dropFactory, setDropFactory] = useState(null);\n  useEffect(() => {\n    const {\n      ethereum\n    } = window;\n    if (!ethereum) return alert(\"Install metamask\");\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const dropFactoryContract = new ethers.Contract(address, abi, signer);\n    setDropFactory(dropFactoryContract);\n  }, [abi, address]);\n\n  const createDrop = async () => {\n    try {} catch (error) {\n      alert(error.message);\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(StakingRewardsFactoryContext.Provider, {\n    value: {\n      address,\n      abi,\n      dropFactory,\n      createDrop\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 44,\n    columnNumber: 5\n  }, this);\n}\n\n_s(StakingRewardsFactoryProvider, \"lLZDu8NoQfs/9VoMJpv1nq51F24=\");\n\n_c = StakingRewardsFactoryProvider;\nexport default StakingRewardsFactoryContext;\n/*\n\nimport React, { createContext, useEffect, useState } from \"react\";\nimport DropFactoryContract from \"../../Contracts/NftDrop.json\";\nimport { ethers } from \"ethers\";\n\nconst DropFactoryContext = createContext();\n\nexport function DropFactoryProvider({ children }) {\n  const address = DropFactoryContract.address;\n  const abi = DropFactoryContract.abi;\n  const [dropFactory, setDropFactory] = useState(null);\n  useEffect(() => {\n    const { ethereum } = window;\n    if (!ethereum) return alert(\"Install metamask\");\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const dropFactoryContract = new ethers.Contract(address, abi, signer);\n    setDropFactory(dropFactoryContract);\n  }, [abi, address]);\n\n  const createDrop = async (\n    maxSupply,\n    name,\n    cid,\n    prefix,\n    sufix,\n    hiddenURI,\n    maxPerTx\n  ) => {\n    try {\n      const tx = await dropFactory.createDrop(\n        ethers.BigNumber.from(maxSupply),\n        name,\n        cid,\n        prefix,\n        sufix,\n        hiddenURI,\n        ethers.BigNumber.from(maxPerTx)\n      );\n      console.log(\"loading...\");\n      await tx.wait();\n      alert(\"drop create succesfully \" + tx.hash);\n    } catch (error) {\n      alert(error.message);\n    }\n  };\n  const totalDrops = async () => {\n    return await dropFactory?.totalDrops();\n  };\n  const getAllDrops = async () => {\n    const dropsCount = await totalDrops();\n    const allDrops = [];\n    for (let i = 0; i < dropsCount; i++) {\n      const drop = await dropFactory.drops(i);\n      allDrops.push(drop);\n    }\n    return allDrops;\n  };\n  const getDropById = async (dropId) => {\n    return await dropFactory?.drops(dropId);\n  };\n  const mintDrop = async (dropId, mintAmount) => {\n    try {\n      const tx = await dropFactory.mint(\n        dropId,\n        ethers.BigNumber.from(mintAmount),\n        {\n          gasLimit: 750000,\n          value: ethers.utils.parseEther(\"0.01\").mul(mintAmount),\n        }\n      );\n      console.log(\"loading...\");\n      await tx.wait();\n      alert(\"mint succesfully \" + tx.hash);\n    } catch (error) {\n      alert(error.message);\n    }\n  };\n  const revealDrop = async(dropId) => {\n    try {\n      const tx = await dropFactory.defineDrop(dropId);\n      console.log(\"loading...\");\n      await tx.wait();\n      alert(\"drop revealed\" + tx.hash);\n    } catch (error) {\n      alert(error.message);\n    }\n  };\n\n  return (\n    <DropFactoryContext.Provider\n      value={{\n        address,\n        abi,\n        getAllDrops,\n        dropFactory,\n        createDrop,\n        totalDrops,\n        getDropById,\n        mintDrop,\n    revealDrop\n      }}\n    >\n      {children}\n    </DropFactoryContext.Provider>\n  );\n}\nexport default DropFactoryContext;\n\n\n\n\n*/\n\nvar _c;\n\n$RefreshReg$(_c, \"StakingRewardsFactoryProvider\");","map":{"version":3,"sources":["/home/alvaradof/cursoSolidity/solidity-liquidity-staking-front/src/context/DropFactory/index.jsx"],"names":["React","createContext","useEffect","useState","DropFactoryContract","StakingRewardsFactoryContract","ethers","StakingRewardsFactoryContext","StakingRewardsFactoryProvider","children","address","address_2","abi","abi_2","alert","dropFactory","setDropFactory","ethereum","window","provider","providers","Web3Provider","signer","getSigner","dropFactoryContract","Contract","createDrop","error","message"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,aAAhB,EAA+BC,SAA/B,EAA0CC,QAA1C,QAA0D,OAA1D;AACA,OAAOC,mBAAP,MAAgC,8BAAhC;AACA,OAAOC,6BAAP,MAA0C,qCAA1C;AACA,SAASC,MAAT,QAAuB,QAAvB;;AAGA,MAAMC,4BAA4B,gBAAGN,aAAa,EAAlD;AAEA,OAAO,SAASO,6BAAT,OAAqD;AAAA;;AAAA,MAAd;AAAEC,IAAAA;AAAF,GAAc;AAC1D,QAAMC,OAAO,GAAGN,mBAAmB,CAACM,OAApC;AACA,QAAMC,SAAS,GAAGN,6BAA6B,CAACK,OAAhD;AAGA,QAAME,GAAG,GAAGR,mBAAmB,CAACQ,GAAhC;AAEA,QAAMC,KAAK,GAAGR,6BAA6B,CAACO,GAA5C;AACAE,EAAAA,KAAK,CAACD,KAAD,CAAL;AAEA,QAAM,CAACE,WAAD,EAAcC,cAAd,IAAgCb,QAAQ,CAAC,IAAD,CAA9C;AACAD,EAAAA,SAAS,CAAC,MAAM;AACd,UAAM;AAAEe,MAAAA;AAAF,QAAeC,MAArB;AACA,QAAI,CAACD,QAAL,EAAe,OAAOH,KAAK,CAAC,kBAAD,CAAZ;AACf,UAAMK,QAAQ,GAAG,IAAIb,MAAM,CAACc,SAAP,CAAiBC,YAArB,CAAkCJ,QAAlC,CAAjB;AACA,UAAMK,MAAM,GAAGH,QAAQ,CAACI,SAAT,EAAf;AACA,UAAMC,mBAAmB,GAAG,IAAIlB,MAAM,CAACmB,QAAX,CAAoBf,OAApB,EAA6BE,GAA7B,EAAkCU,MAAlC,CAA5B;AACAN,IAAAA,cAAc,CAACQ,mBAAD,CAAd;AACD,GAPQ,EAON,CAACZ,GAAD,EAAMF,OAAN,CAPM,CAAT;;AASA,QAAMgB,UAAU,GAAG,YAEd;AACH,QAAI,CAEH,CAFD,CAEE,OAAOC,KAAP,EAAc;AACdb,MAAAA,KAAK,CAACa,KAAK,CAACC,OAAP,CAAL;AACD;AACF,GARD;;AAcA,sBACE,QAAC,4BAAD,CAA8B,QAA9B;AACE,IAAA,KAAK,EAAE;AACLlB,MAAAA,OADK;AAELE,MAAAA,GAFK;AAGLG,MAAAA,WAHK;AAILW,MAAAA;AAJK,KADT;AAAA,cAQGjB;AARH;AAAA;AAAA;AAAA;AAAA,UADF;AAYD;;GA9CeD,6B;;KAAAA,6B;AA+ChB,eAAeD,4BAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import React, { createContext, useEffect, useState } from \"react\";\nimport DropFactoryContract from \"../../Contracts/NftDrop.json\";\nimport StakingRewardsFactoryContract from \"../../Contracts/StakingRewards.json\";\nimport { ethers } from \"ethers\";\n\n\nconst StakingRewardsFactoryContext = createContext();\n\nexport function StakingRewardsFactoryProvider({ children }) {\n  const address = DropFactoryContract.address;\n  const address_2 = StakingRewardsFactoryContract.address;\n  \n  \n  const abi = DropFactoryContract.abi;\n   \n  const abi_2 = StakingRewardsFactoryContract.abi;\n  alert(abi_2)\n  \n  const [dropFactory, setDropFactory] = useState(null);\n  useEffect(() => {\n    const { ethereum } = window;\n    if (!ethereum) return alert(\"Install metamask\");\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const dropFactoryContract = new ethers.Contract(address, abi, signer);\n    setDropFactory(dropFactoryContract);\n  }, [abi, address]);\n\n  const createDrop = async (\n    \n  ) => {\n    try {\n     \n    } catch (error) {\n      alert(error.message);\n    }\n  };\n \n \n  \n  \n\n  return (\n    <StakingRewardsFactoryContext.Provider\n      value={{\n        address,\n        abi,\n        dropFactory,\n        createDrop\n      }}\n    >\n      {children}\n    </StakingRewardsFactoryContext.Provider>\n  );\n}\nexport default StakingRewardsFactoryContext;\n\n/*\n\nimport React, { createContext, useEffect, useState } from \"react\";\nimport DropFactoryContract from \"../../Contracts/NftDrop.json\";\nimport { ethers } from \"ethers\";\n\nconst DropFactoryContext = createContext();\n\nexport function DropFactoryProvider({ children }) {\n  const address = DropFactoryContract.address;\n  const abi = DropFactoryContract.abi;\n  const [dropFactory, setDropFactory] = useState(null);\n  useEffect(() => {\n    const { ethereum } = window;\n    if (!ethereum) return alert(\"Install metamask\");\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const dropFactoryContract = new ethers.Contract(address, abi, signer);\n    setDropFactory(dropFactoryContract);\n  }, [abi, address]);\n\n  const createDrop = async (\n    maxSupply,\n    name,\n    cid,\n    prefix,\n    sufix,\n    hiddenURI,\n    maxPerTx\n  ) => {\n    try {\n      const tx = await dropFactory.createDrop(\n        ethers.BigNumber.from(maxSupply),\n        name,\n        cid,\n        prefix,\n        sufix,\n        hiddenURI,\n        ethers.BigNumber.from(maxPerTx)\n      );\n      console.log(\"loading...\");\n      await tx.wait();\n      alert(\"drop create succesfully \" + tx.hash);\n    } catch (error) {\n      alert(error.message);\n    }\n  };\n  const totalDrops = async () => {\n    return await dropFactory?.totalDrops();\n  };\n  const getAllDrops = async () => {\n    const dropsCount = await totalDrops();\n    const allDrops = [];\n    for (let i = 0; i < dropsCount; i++) {\n      const drop = await dropFactory.drops(i);\n      allDrops.push(drop);\n    }\n    return allDrops;\n  };\n  const getDropById = async (dropId) => {\n    return await dropFactory?.drops(dropId);\n  };\n  const mintDrop = async (dropId, mintAmount) => {\n    try {\n      const tx = await dropFactory.mint(\n        dropId,\n        ethers.BigNumber.from(mintAmount),\n        {\n          gasLimit: 750000,\n          value: ethers.utils.parseEther(\"0.01\").mul(mintAmount),\n        }\n      );\n      console.log(\"loading...\");\n      await tx.wait();\n      alert(\"mint succesfully \" + tx.hash);\n    } catch (error) {\n      alert(error.message);\n    }\n  };\n  const revealDrop = async(dropId) => {\n    try {\n      const tx = await dropFactory.defineDrop(dropId);\n      console.log(\"loading...\");\n      await tx.wait();\n      alert(\"drop revealed\" + tx.hash);\n    } catch (error) {\n      alert(error.message);\n    }\n  };\n\n  return (\n    <DropFactoryContext.Provider\n      value={{\n        address,\n        abi,\n        getAllDrops,\n        dropFactory,\n        createDrop,\n        totalDrops,\n        getDropById,\n        mintDrop,\n    revealDrop\n      }}\n    >\n      {children}\n    </DropFactoryContext.Provider>\n  );\n}\nexport default DropFactoryContext;\n\n\n\n\n*/"]},"metadata":{},"sourceType":"module"}